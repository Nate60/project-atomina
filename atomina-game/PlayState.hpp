#pragma once
#include <atomina.hpp>
#include "GameStateType.hpp"
#include "GameEventType.hpp"

using namespace std::string_literals;

class PlayState: public ATMA::BaseState, public ATMA::ObjectEventListener
{
public:
    ATMA::ATMAContext &ctx = ATMA::ATMAContext::getContext();

    PlayState(const unsigned int &l_vertID, const unsigned int &l_fragID): ATMA::BaseState()
    {
        auto vertShader = ctx.loadResource<ATMA::GLShader>(l_vertID);
        vertShader->compile(ATMA::ShaderType::Vertex);
        auto fragShader = ctx.loadResource<ATMA::GLShader>(l_fragID);
        fragShader->compile(ATMA::ShaderType::Fragment);
        m_defaultProg = ATMA::GLProgram::makeProgram();
        m_defaultProg->attachShader(vertShader);
        m_defaultProg->attachShader(fragShader);
        m_defaultProg->link();
        auto playerTextID = ctx.registerResource("shaggy player", 0u, "res/shaggysheet.png");
        m_playerTexture = ctx.loadResource<ATMA::GLTexture>(playerTextID);
        m_playerID = ctx.createObject();
    }

    virtual ~PlayState() {}

    /**
     * stub implementation of activate function
     */
    virtual void activate() override
    {
        ctx.addAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Render));
        ctx.addAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Velocity));
        ctx.addAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Shape));
        ctx.addAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Controllable));
        ctx.addAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Collidable));
        auto playerRender = ctx.getAttribute<ATMA::AttrRenderable>(
            m_playerID, ATMA::AttributeType(ATMA::Attribute::Render)
        );
        playerRender->m_self->m_prog = m_defaultProg;
        playerRender->m_self->m_texture = m_playerTexture;
        playerRender->m_self->m_size = ATMA::Vec2<float>{0.1f, 0.2f};
        playerRender->m_self->m_pos = ATMA::Vec2<float>{0.f, 0.f};
        playerRender->m_self->m_stackPos = 0;
        m_active = true;
    }

    /**
     * stub implementation of deactive function
     */
    virtual void deactivate() override
    {
        ctx.removeAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Render));
        ctx.removeAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Velocity));
        ctx.removeAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Shape));
        ctx.removeAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Controllable));
        ctx.removeAttribute(m_playerID, ATMA::AttributeType(ATMA::Attribute::Collidable));
        m_active = false;
    }

    /**
     * gets state id
     * @returns state id
     */
    virtual unsigned int getId() const override
    {
        return GameStateType(GameStateEnum::PLAYSTATE);
    }

    /**
     * passes window events to be handled by the state
     * @param l_winEvent the event generated by the window
     * @returns whether or not the event was handled
     */
    virtual void handleInput(const ATMA::WindowEvent &l_winEvent)
    {
        if(!m_active)
            return;
        switch(l_winEvent.m_type)
        {
        case ATMA::WindowEventEnum::KeyDowned:
        {
            ATMA::KeyEnum keycode = ATMA::KeyEnum(l_winEvent.getProp<int>("keycode"s));
            switch(keycode)
            {
            case ATMA::KeyEnum::ESCAPE:
                ctx.switchToState(GameStateType(GameStateEnum::MAINMENU));
                break;
            case ATMA::KeyEnum::SPACE:
                ctx.dispatchObjectEvent(ATMA::ObjectEventContext{
                        GameEventType(GameEventEnum::FLAP), ATMA::Props{}
                });
                break;
            }
            break;
        }
        case ATMA::WindowEventEnum::Closed:
            l_winEvent.m_win->notifyClose();
            break;
        }
    }

    /**
     * Triggers any event specific functionality of the system
     * @param l_e event details of the passed event
     */
    virtual void notify(const ATMA::ObjectEventContext &l_e) override
    {
        auto playerVel = ctx.getAttribute<ATMA::AttrVelocity>(
            m_playerID, ATMA::AttributeType(ATMA::Attribute::Velocity)
        );
        playerVel->m_drot = 8.9f;
        m_gameOver = true;
        ctx.addAttribute(m_gameOverID, ATMA::AttributeType(ATMA::Attribute::Render));
        ctx.getAttribute<ATMA::AttrRenderable>(
               m_gameOverID, ATMA::AttributeType(ATMA::Attribute::Render)
        )
            ->m_self = m_gameOverText;

        m_gameOverText->m_text = "Game Over";
        m_gameOverText->m_texture = m_font;
        m_gameOverText->m_size = ATMA::Vec2<float>{0.04f, 0.1f};
        m_gameOverText->m_pos = ATMA::Vec2<float>{-0.3f, 0.22f};
        m_gameOverText->m_stackPos = 1;
        ctx.onUpdate([&](const long long &l_dt) {});
    }
private:
    bool m_started{false}, m_gameOver{false};
    unsigned int m_playerID{}, m_promptID{}, m_gameOverID{}, m_highScoreID{}, m_highScore{},
        m_firstPipe{};
    std::shared_ptr<ATMA::GLProgram> m_defaultProg;
    std::shared_ptr<ATMA::GLTexture> m_playerTexture;
    std::shared_ptr<ATMA::GLTexture> m_wallTexture;
    std::shared_ptr<ATMA::GLTexture> m_font;
    std::shared_ptr<ATMA::GLText> m_highscoreText = ATMA::GLText::makeText();
    std::shared_ptr<ATMA::GLText> m_gameOverText = ATMA::GLText::makeText();
    ATMA::RandomGenerator<float> m_floatRand{};
    long long m_lastSpawn{0};

    std::vector<std::pair<unsigned int, unsigned int>> m_pipes{};
};